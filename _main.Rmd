--- 
title: "Winter Bioinformatics School"
author:
  - name: Winter School
    affiliation:
    - cursos@wintergenomics.com
book_filename: "Winter School.Rmd"
site: bookdown::bookdown_site
output: 
  bookdown::gitbook:
    config:
    toolbar:
      position: fixed
    edit : null
    download: 
    - ["book.pdf", "PDF"]
documentclass: book
github-repo: "wintergenomics/wbs-rbioinfo"
---

# Información del curso {-}
**7 y 8 de octubre de 2021**

<p align="justify">

¡Bienvenidos al curso de R para bioinformática de [Winter Genomics](https://www.wintergenomics.com/) y [Winter School](https://www.wintergenomics.com/index.php/soluciones/winter-school/)!

R es un lenguaje básico de referencia en el mundo de la estadística y una herramienta fundamental para el análisis de datos en el área de las ciencias de la vida. R permite automatizar los cálculos estadísticos y la generación de diversos gráficos para facilitar el análisis de datos. 

R, al ser uno de los lenguajes más utilizados por científicos en numerosas disciplinas, está diseñado para manipular y analizar grandes cantidades de datos.


Durante este curso aprenderás las herramientas básicas de R para analizar datos. Revisaremos qué son los lenguajes de programación, los tipos de lenguajes de programación que existen. Después veremos los tipos de objetos, datos y atributos más usados en R como vectores, matrices, data.frames. Aprenderás a generar proyectos y realizar gráficos de boxplots, scatter plots y heatmaps usando ggplot2.

</p>

## Formato del curso {-}

<p align="justify">

Este es un curso digital donde las sesiones y el material del curso son en línea. Las sesiones del curso han sido grabadas y se te han compartido al correo que utilizaste al realizar tu registro al curso en la carpeta de Google Drive del curso junto con el material y presentaciones. 
</p>

## ¿Quién es nuestra audiencia? {-}

<p align="justify">

Este curso está diseñado para todos aquellos interesados en adentrarse a la bioinformática, a la programación y al análisis de datos de las ciencias biológicas. El curso es nivel básico, por lo que no es necesario tener conocimientos previos de programación.

</p>

## Pre-requisitos {-}

- Tener una computadora con al menos 8Gb de memoria y permisos de administrador para instalar paqueterías de R.
- Tener instalado R y RStudio en su última versión.

### Instalación de R y RStudio {-}
<p align="justify">

Para este curso es necesario tener instalada la última versión de R y RStudio. Si no lo tienes, en esta [guía](https://drive.google.com/file/d/1yFlFoG_cjpVyOhGHaB5I76xXASDmp70_/view) te enseñamos cómo hacerlo.

Si tienes problemas durante la instalación, escríbenos a cursos@wintergenomics.com

</p>

<!--chapter:end:index.Rmd-->


# Lenguajes y principios de programación

Un lenguaje es un vocabulario y un conjunto de reglas gramaticales para
instruir a una computadora o dispositivo informático para
realizar tareas específicas.

Esto se realiza mediante un script. Un script es una lista de comandos que se ejecutan linea a linea.
Son sólo documentos de texto que contienen instrucciones escritas en un
determinado lenguaje de secuencias de comandos.

**Descarga y revisa el material completo del contenido de Lenguajes y principios de programación [aquí](https://drive.google.com/u/0/uc?id=1I1camM0V_96clNeCMdvo0td1C9P0km7a&export=download)**



Si tienes problemas durante la descarga, escríbenos a cursos@wintergenomics.com

<!--chapter:end:01-intro.Rmd-->


# Introducción a R y RStudio para bioinformática

R es un lenguaje básico de referencia en el mundo de la estadística y una herramienta fundamental para el análisis de datos en el área de las ciencias de la vida. R permite automatizar los cálculos estadísticos y la generación de diversos gráficos para facilitar el análisis de datos. 

R es uno de los lenguajes más utilizados por científicos en numerosas disciplinas y está diseñado para manipular y analizar grandes cantidades de datos.


**Descarga y revisa el material completo del contenido [aquí](https://drive.google.com/u/0/uc?id=1vd9iHq1gL_43NgpviuzsX7CiUmO25v1M&export=download).**


Si tienes problemas durante la descarga, escríbenos a cursos@wintergenomics.com

<!--chapter:end:02-Rbioinfo.Rmd-->

---
output:
  pdf_document: default
  html_document: default
---

# Objetos

Todos los elementos que maneja R se llaman objetos

En términos prácticos:

Es un nombre que almacena cualquier tipo y cantidad de datos (inputs o outputs) con atributos específicos.

## Creación de objetos

En R podemos asignar valores a objetos con el siguiente símbolo para la asignación 	`<-`
Ejemplo:

```{r}
x <- 1
```
Donde x es la variable y 1 es el objeto

**¿Cuál sería otra forma de mostrar el valor de x usando una función?**				

Es importante mantener la estructura de la función u operación, y en ocasiones no importa agregar más espacios, por ejemplo:

```{r}
y  <- 1 + 2
y
```


Al incluir más espacios, sigue produciendo el mismo resultado
```{r}
y  <-      1       +      3
y
```

### Ejercicio

Asigna el resultado de multiplicar 2 por 8 a la variable cromosomas
```{r}
cromosomas <- 2*8
cromosomas
```

Ahora asigna el valor 3400 a la variable cromosomas.

Para R, no es lo mismo: Juan y “Juan”.

Juan (sin comillas) es el nombre de un objeto

## Tipos de datos en R

```{r, echo=F, eval=T, results='hide'}
  tdata<- c("Caracter", "Numérico", "Lógico")
  dato<- c("Id de paciente", "Cigarrillos por día", "¿Fumador?")
  ejem<- c ('"Alejandra", "IMSS_311"', "9, 4.15, 1000", "TRUE (T), FALSE (F)")
  tddf <- data.frame(Tipos= tdata, Dato=dato, Ejemplo=ejem)
  tddf
```

```{r, echo=FALSE}
knitr::kable(
  tddf, booktabs = TRUE)
```

**NUMÉRICO**

Agrega un valor numérico a la variable mi_numero
```{r}
mi_numero <- 30
```

**CARACTER**

Agrega la siguiente palabra a mi_caracter: Mexico
```{r}
mi_caracter <- "Mexico"
```
**NOTA: Cuando usamos texto debemos escribirlo entre " " (comillas)**

**LÓGICO**

Agrega el valor lógico
```{r}
mi_logico <- TRUE
```

Podemos conocer la clase a la que corresponde cada uno de nuestros datos con la función `class()`

```{r}
class(mi_numero)
```

```{r}
class(mi_caracter)
```

```{r}
class(mi_logico)
```


Es posible convertir la clase de un objeto usando las siguientes funciones:

- `as.numeric()`
- `as.logical()`
- `as.character()`
- `as.integer()`

**Ejemplo**
Convierte `mi_numero` a caracter usando la función `as.character()`

```{r}
mi_numero
```

```{r}
class(mi_numero)
```

```{r}
as.character(mi_numero)
```

## Tipos de objetos en R

- **Vectores:** Son secuencias uni-dimensionales de elementos.
- **Matrices:** Son objetos de bi-dimensionales. El contenido de este objeto debe de ser de un solo tipo de datos.
- **Factores:** Son vectores de tipo categóricos, pueden contener datos numéricos, integrales o caracteres.
- **Listas:** Las listas son parecidas a los vectores, pero a diferencia de estas, no tienen que contener el mismo tipo de datos.
- **Data frames:** Es una matriz pero puede contener datos de diferentes tipos, ya sea numéricos o tipo carácter.



```{r, echo=F, eval=T, results='hide'}
  tdd<- c("Vector", "Matriz", "Data.frame", "Listas")
  ej<- c("c(“Mary”,”Juan”, … )", "matrix(37, 20, 25, 17, … )", "data.frame(ID_Pacientes, cigarrillos por día, Fumador)", "list(mi_vector, mi_matriz, mi_dataframe, mi gráfico)")
  desc<- c("Colección de datos en serie", "Vector ordenado por filas y columnas", "Colección de vectores ordenados por columnas; todos los vectores deben ser de la misma longitud", "Son contenedores generales de datos. Muy flexibles, pero sin estructura")
  todf <- data.frame(Tipos= tdd, Ejemplo=ej, Descripción=desc)
  todf
```

```{r, echo=FALSE}
knitr::kable(
  todf, booktabs = TRUE)
```

## Atributos de los objetos
Los atributos de los objetos pueden ser:

- Nombres
- Dimensiones
- Clases
- Longitud 
- Otros atributos definidos por el usuario

Se pueden acceder a estos atributos usando la función `attributes()`

## Operadores

### Operadores artiméticos

```{r, echo=F, eval=T, results='hide'}
  aritm<- c("+","-", "*", "/", "^", "%%", "%/%")
  desc<- c("Adición", "Substracción", "Multiplicación", "División", "Exponente", "Residuo de división", "División entera")
  aritdf <- data.frame(Aritmético= aritm, Descripción=desc)
```

```{r, echo=FALSE}
knitr::kable(
  aritdf, booktabs = TRUE)
```

### Operadores Relacionales
```{r, echo=F, eval=T, results='hide'}
  rel<- c("<",">","<=", ">=", "==", "!=")
  desc_rel<- c("Menor que", "Mayor que", "Menor o igual que", "Mayor o igual que", "Igual que", "No igual que")
  reldf <- data.frame(Relacionales= rel, Descripción=desc_rel)
```

```{r, echo=FALSE}
knitr::kable(
  reldf, booktabs = TRUE)
```

### Operadores Lógicos
```{r, echo=F, eval=T, results='hide'}
  logi<- c("!", "&", "&&", "|", "||")
  desc_log<- c("No lógico", "Y lógico por elemento", "Y lógico", "O lógico por elemento", "O lógico")
  logdf <- data.frame(Lógico= logi, Descripción=desc_log)
```

```{r, echo=FALSE}
knitr::kable(
  logdf, booktabs = TRUE)
```

<!--chapter:end:03-obj_atbr.Rmd-->

# Vectores

Los vectores son cadenas unidimensionales (es decir una sola columna o fila) de un mismo tipo de valores (numéricos, caracteres, etc.)
Para crear un vector se usa la función `combinar c()`

```{r}
longitud <- c(12,11,15,13,16,12,11)
```

```{r}
colores  <- c("Negro", "Rosa", "Amarillo", "Blanco", "Azul", "Marron", "Guinda")
```

El objeto más simple que se puede almacenar en R es un vector con 1 elemento.
```{r}
simple <- "Dora"
```

## Manejo de vectores
Creamos el vector *PesosPacientes* utilizando datos de pesos de diferentes pacientes:
```{r}
PesosPacientes <- c(55, 45, 85, 55, 63, 78, 57) 
```

Para acceder a elementos específicos de cada vector usamos los corchetes indicando el elemento al que queremos acceder. En este ejemplo accederemos al peso del paciente 5:
```{r}
PesosPacientes[5]
```

La longitud del vector se obtiene con la función `length()`
```{r}
length(PesosPacientes)
```

Para extraer de nuestro objeto más de un elemento se usa la función para combinar o concatenar `c()`. En este ejemplo vamos a usar los pesos de los pacientes 3 y 6:
```{r}
PesosPacientes[c(3,6)]
```

También podemos usar índices negativos para quitar temporalmente ciertos elementos de un vector. En este ejemplo vamos a quitar los pesos de los pacientes 3 y 6:
```{r}
PesosPacientes[-c(3,6)]
```


## Operaciones con vectores
Para hacer una operación utilizando varios números a la vez usamos la función combinar `c()`
```{r}
PesosPacientes <- c(55, 45, 85, 55, 63, 78, 57)
```

Para ver los valores, tecleamos **PesosPacientes** en la consola. El *+ 1* sumará uno al peso de cada paciente
```{r}
PesosPacientes + 1
```

## Funciones en vectores

Se pueden usar diferentes funciones para aplicarse a los vectores numéricos.

La función `sum()`permite realizar la sumas de los datos.
```{r}
sum(PesosPacientes)
```

La función `mean()` calcula el promedio.
```{r}
mean(PesosPacientes)
```

La función `max()` indica el valor más alto de nuestros datos.
```{r}
max(PesosPacientes)
```

La función `sort()` ordena de menor a mayor los valores.
```{r}
sort(PesosPacientes)
```

La función `unique()` muestra los datos o valores únicos o que no se repiten de nuestro set.
```{r}
unique(PesosPacientes)
```

En R también podemos tener valores de texto que siempre van entre comillas. 
Así como guardamos una serie de números en el objeto **“PesosPacientes”**, podemos guardar valores de texto en un nuevo objeto de la siguiente manera:
```{r}
nombres <- c("Susana", "Angela", "Oscar", "Joel", "Blanca", "Karla", "Manuel")
```

El objeto “nombres” nos puede servir para etiquetar los valores numéricos de los pesos de los pacientes, esto con la función `names()` para asignar nombres de texto.
```{r}
names(PesosPacientes) <- nombres
PesosPacientes
```



<!--chapter:end:04-vectores.Rmd-->


# Matrices
Una matriz es una estructura de datos, ordenados por filas y columnas (matriz de dos dimensiones). Está constituida por elementos del mismo tipo de datos (numéricos, caracteres, o lógicos), organizados por filas y columnas.

## Estructura de una matriz
```{r}
matrix(nrow=2, ncol=3)
```
Donde:
- **nrow** es el  número de filas
- **ncol** es el número de columnas
- **NA** significa *Not Available*
```{r}
matrix(1:9, byrow = TRUE, nrow = 3)
```
- El argumento `1:9`es una colección de elementos: `1:9 c(1,2,4,5,6,7,8,9)`
- `byrow` indica que la matriz será rellenada por fila. Si queremos que la matriz sea llenada por columna ajustamos a `byrow = FALSE`
- `nrow` indica que la matriz tendrá 3 filas

## Creación de una matriz
```{r}
MatrixEjemplo <- matrix(1:12, nrow = 4, byrow=TRUE)
MatrixEjemplo
```
```{r}
dim(MatrixEjemplo)
```
- `byrow=TRUE` llena los elementos por fila.
- Con el comando `dim()`se obtiene las dimensiones de la matriz

## Acceder a los elementos de una matri
Supongamos que queremos acceder al elemento que se encuentra en la fila 3 y la columna 2 de nuestra `MatrixEjemplo`. Para esto debemos de indicar entre corchetes la fila y la columna a la que queremos acceder. **Es muy importante indicar primero la fila y después la columna.**
```{r}
MatrixEjemplo[3,2]
```
Ahora guardemos el resultado en la variable elemento:
```{r}
elemento<- MatrixEjemplo[3,2]
elemento
```
Si queremos acceder únicamente a los datos de la fila 3 de nuestra matriz usamos:
```{r}
MatrixEjemplo[3,]
```

La coma después del número 3 indica que queremos ver todos los valores de las columnas que pertenezcan a la fila 3. 
Si por el contrario, queremos acceder a los valores de la columna dos, usamos:
```{r}
MatrixEjemplo[,2]
```

En este caso, la coma está situada antes del número 2 indicando que queremos ver todos los valores de las filas que pertenezcan a la columna 2. 
Guardemos los resultados en diferentes variables:
```{r}
fila<- MatrixEjemplo[3,]
fila
```
```{r}
columna<- MatrixEjemplo[,2]
columna
```
## Modificar elementos de una matriz
Para modificar cualquier elemento de una matriz debemos de indicar entre corchetes el número de fila y de columna en donde se encuentra el elemento que queremos modificar: `[fila, columna]`.
Vamos a modificar el elemento que se encuentra en la fila 2 de la columna 2.
```{r, echo=F, eval=T}
MatrixEjemplo
```
El elemento que queremos cambiar tiene el valor de *"5"*. Vamos a sustiurlo por el valor de 10. Para esto lo reasignamos a nuestra matriz:
```{r}
MatrixEjemplo[2,2]<- 10
MatrixEjemplo
```
- **MatrixEjemplo[2,2]** indica que queremos acceder al elemento que se encuentra en la fila 2 de la columna 2. 
- **<- 10** estamos asignando el valor 10 a la matriz.
## Ejercicio
Construir una matriz con los años de secuenciación de organismos de referencia (G). El primer y el segundo elemento es el año de publicación de al menos dos organismos.

```{r}
Gbacterias <- c(1997, 1993)
Ghongos <- c(1999, 2000)
Ganimales <- c(2000, 2001)
cronologia <- c(Gbacterias, Ghongos, Ganimales)
```

Construir matriz de 3 filas, 2 columnas con los valores de cronologia
```{r}
matrix(cronologia, nrow = 3)
```
Para agregar columnas o filas a matrices utilizamos `cbind()` y `rbind()` respectivamente.

**NOTA:** El número de elementos en las columnas o filas debe ser el mismo.

```{r}
cbind(Ganimales,Gbacterias,Ghongos)
```

```{r}
rbind(Ganimales,Gbacterias,Ghongos)
```

**NOTA:** Estos resultados los podemos guardar en distintas variables.

<!--chapter:end:05-matrices.Rmd-->


# Data.frames

Es una estructura de tipo tabular, que permite el uso de diferentes tipos de datos. Combina listas de vectores de la misma longitud. 
Ejemplo, en una encuesta se tienen preguntas como las siguientes con sus respectivas respuestas:

- ¿Está vacunado para Influenza? : **sí/no (lógicos)**
- ¿Año de nacimiento? : **1990, 1981, 2000, 1952 (numérico)**
- ¿Nacionalidad?: **Chi, Rus, Mex, USA (caracteres)**

## Características de los data.frames

- Los nombres de columna no deben estar vacíos
- Los nombres de las filas deben ser **únicos**
- Los datos almacenados en un dataframe pueden ser de tipo numérico, factor o carácter.
- Cada columna debe contener el mismo número de elementos de datos

## Creación de un data.frame

Crear data.frame *"TipoDatos"* a partir de los siguientes vectores:
```{r}
origen <- c("Chi", "Rus", "Mex", "USA")
vacunado <- c(FALSE, TRUE, TRUE, TRUE)
fecha <- c("1990", "1981", "2000", "1952")
TipoDatos <- data.frame(origen, vacunado, fecha)
TipoDatos
```

`str()` Brinda información sobre la estructura del data.frame.

```{r}
str(TipoDatos)
```

Para acceder a una columna de un data.frame, utilizamos el símbolo de pesos:
```{r}
TipoDatos$fecha
```

Otra forma de acceder a los elementos de un data.frames es mediante corchetes. Recordemos que esta nomenclatura la estudiamos en el capítulo anterior de Matrices. 
```{r}
TipoDatos[,3]
```


De manera similar, para acceder a una fila de un data.frame utilizamos los corchetes, donde `[fila, columna]`. 
```{r}
TipoDatos[2,]
```


## Extracción de datos de un data.frame
### Extracción de datos por columna

Crear un nuevo data.frame llamado "result" que contenga todos los datos de las columnas origen y fecha. 
```{r}
result <- data.frame(TipoDatos$origen,TipoDatos$fecha)
result
```


### Extracción de datos por filas

Extraer todos los datos de las filas 1 y 2. 
```{r}
subsets <- TipoDatos[1:2,]
subsets
```


## Combinar data.frames

Creamos un segundo data.frame llamado *"TipoDatos2"*.
```{r}
cobertura <- c("NA", "Pandemica", "Estacional", "NA")
edad <- factor(c("60", "50", "80", "20"), ordered = TRUE)
TipoDatos2 <- data.frame(cobertura, edad)
TipoDatos2
```

Con `cbind()` unimos dos data.frames del mismo tamaño mediante columnas. En este caso uniremos los data.frames `TipoDatos` y `TipoDatos2`.
```{r}
datosfinales <- cbind(TipoDatos,TipoDatos2)
datosfinales
```


## Subset de datos

`subset()` permite filtrar o extraer los datos que cumplen con un parámetro particular.

Si queremos obtener los datos de los pacientes menores a 60 años usamos:
```{r}
subset(datosfinales, subset=edad <60)
```

Si queremos obtener los datos de los pacientes vacunados usamos:
```{r}
subset(datosfinales, subset=vacunado)
```


Estos resultados los podemos guardar en distantas variables

```{r}
pacientes_edad<- subset(datosfinales, subset=edad <60)
pacientes_edad
```

```{r}
pacientes_vacunados<- subset(datosfinales, subset=vacunado)
pacientes_vacunados
```


<!--chapter:end:06-dataframes.Rmd-->


# Importación y exportación de datos

## Estableciendo nuestro directorio de trabajo

Establecer nuestro directorio de trabajo nos permite tener una mejor organización mientras trabajamos en R. 
Para conocer nuestro directorio de trabajo actual, usamos `getwd()`
```{r, eval=F}
getwd() 
```

Asigna a un objeto la ruta de la carpeta de trabajo. Recuerda cambiar */docs/mydir* por los nombres de tus carpetas de trabajo
```{r}
directory <- "C:/docs/mydir" #Windows
directory <- "/home/users/mydir"  #Mac OS o linux
```

`setwd()` permite ajustar el directorio de trabajo. Vamos a ajustarlo a la ruta de trabajo que guardamos en `directory`
```{r, eval=F}
setwd(directory)
```

## Importación de datos
### Archivos CSV

Importa archivos de texto plano con formato CSV (*coma-separated values*). Los datos los puedes descargar de [aquí](https://drive.google.com/u/0/uc?id=1aS5-Zf03OeMRtZsCCLYFXAUQpesGy4IK&export=download). Recuerda guardarlos en la carpeta de trabajo que asignaste en el paso anterior.
```{r, eval=F}
datosRCSV <- read.csv("iris.csv")
```
```{r, eval=T, echo=F}
datosRCSV <- read.csv("~/Downloads/Datos.csv")
```

```{r}
head(datosRCSV)
```


### Archivos TXT

Importa archivos de texto plano con formato de tabla (data.frame). Los datos los puedes descargar de [aquí](https://drive.google.com/u/0/uc?id=18Cgt4ret3utAuk4w2_jl8RIbKxteulIO&export=download). Recuerda guardarlos en la carpeta de trabajo.
```{r, eval=F}
datosRT <- read.table("iris.txt")
```

```{r, eval=T, echo=F}
datosRT <- read.table("~/Downloads/iris.txt")
```
```{r}
head(datosRT)
```

Notamos que los encabezados no forman parte de la tabla y que R genera sus propios encabezados. Para evitar esto, si el archivo que queremos importar contiene encabezados, el argumento `header` permite incorporar el encabezado del archivo que queremos importar.
```{r, eval=F}
datosRT <- read.table("iris.txt", header=TRUE)
```

```{r, eval=T, echo=F}
datosRT <- read.table("~/Downloads/iris.txt", header=TRUE)
```
```{r}
head(datosRT)
```


Importemos este [nuevo set de datos](https://drive.google.com/u/0/uc?id=1D88k0cC5TeALDWbvRmLh07g2d65ImLHh&export=download). 


```{r, eval=F}
datosRT <- read.table("iris2.txt", header=TRUE)
```

```{r, eval=T, echo=F}
datosRT <- read.table("~/Downloads/iris2.txt", header=TRUE)
```
```{r}
head(datosRT)
```
Los datos no se importaron correctamente y están separados por el símbolo **"|"** o *pipe*.

Los archivos *csv* están separados por comas y generalmente, los archivos *txt* están separados por tabulaciones. Para indicarle a R el tipo de separación que tiene nuestro archivo, usamos el argumento `sep`.

En el siguiente comando, el argumento `sep="|"` le indica a R que nuestros datos están separados por el símbolo **"|"** o *pipe*.

```{r, eval=F}
datosRT <- read.table("iris2.txt", header=TRUE, sep = "|")
```

```{r, eval=T, echo=F}
datosRT <- read.table("~/Downloads/iris2.txt", header=TRUE, sep = "|")
```
```{r}
head(datosRT)
```

## Exportación de datos

Vamos a crear un data.frame para practicar cómo exportar los datos.
```{r}
DosisX <- c(46, 20, 80, 100, 63)
DosisY <- c(6, 50, 70, 70, 63)
Lcelular <- c("MCF7", "Hela", "IPC-366", "T47D", "ZR75-1")
tablaDE <- data.frame(DosisX, DosisY, Lcelular)
tablaDE
```

### Exportar como TXT

Vamos a guardar el data.frame `tablaDE` como un archivo de texto llamado **"datos.txt"** utilizando el comando `write.table()`. La tabla se guardará en nuestro directorio de trabajo  actual.
```{r, eval=F}
write.table(tablaDE, "datos.txt")
```


### Exportar como CSV

Vamos a guardar el data.frame `tablaDE` como un archivo csv llamado **"datos.csv"** utilizando el comando `write.csv()`. La tabla se guardará en nuestro directorio de trabajo  actual.
```{r, eval=F}
write.csv(tablaDE, "datos.csv")
```

### Argumentos al exportar

Así como al importar archivos existen diversos argumentos que podemos utilizar para darles ciertas indicaciones a R, también lo podemos hacer al momento de exportar los datos. Los siguientes argumentos se pueden usar con `write.csv()` y `write.table()`.

`row.names=FALSE` nos permite suprimir los nombres de las filas
```{r, eval=F}
write.csv(tablaDE, "datos1.csv", row.names=FALSE)
```

Para indicar la separación del archivo utilizamos `sep`. Vamos a usar la tabulación como separador poniendo `sep="\t"`.
```{r, eval=F}
write.csv(tablaDE, "datos2.csv", row.names=FALSE, sep="\t")
```


Para suprimir los nombres de las columnas, usamos `col.names=FALSE`
```{r, eval=F}
write.csv(tablaDE, "datos3.csv", row.names=FALSE, sep="\t", col.names=FALSE)
```



## Archivos xlsx o de Excel

Para importar o exportar archivos de Excel, es necesario utilizar la paquetería `"openxlsx"` que nos permite trabajar con documentos de Excel en R. La instalación de paqueterías se realiza sólo una vez. Una vez que la librería o paquetería esté instalada, puedes omitir este paso.

```{r, eval=FALSE}
install.packages("openxlsx", dependencies = TRUE)
```

Ahora cargaremos la paquetería. El llamado de librerías deberá hacerse cada que inicies una nueva sesión en R.
```{r}
library(openxlsx)
```

El siguiente comando te permite leer y conocer más sobre las funciones que ofrece esta paquetería.
```{r}
?openxlsx
```


### Importación de datos xlsx o de Excel

Importaremos un nuevo set de datos de Excel que puedes descargar de [aquí](https://drive.google.com/u/0/uc?id=1DmLiZZGq_MVkLYCMZ7rdeHydUZAoP-YW&export=download). Recuerda guardarlos en tu carpeta de trabajo.

```{r, eval=FALSE}
datosXLSX <- read.xlsx("iris.xlsx")
```

```{r, eval=T, echo=F}
datosXLSX <- read.xlsx("~/Downloads/iris.xlsx")
```
```{r}
head(datosRT)
```


### Exportación de datos en Excel

Vamos a exportar el data.frame `tablaDE` que creamos anteriormente como un archivo de Excel llamado **"datos.xlsx"** utilizando el comando `write.xlsx()`. El archivo se guardará en nuestro directorio de trabajo  actual.

```{r, eval=F}
write.xlsx(tablaDE, "datos.xlsx")
```



<!--chapter:end:07-importacion_datos.Rmd-->


# Instalación de paqueterías
Las paqueterías o librerías son herramientas que se utilizan en R y facilitan la manipulación de datos y realizar diferentes tipos de análisis y gráficos. Las paqueterías se pueden descargar desde tres repositorios principales:

+ [CRAN](https://cran.r-project.org/)
+ [Bioconductor](https://www.bioconductor.org/)
+ [GitHub](https://github.com/)

Cada paquetería contiene su manual o documentación para conocer las opciones o argumentos que se pueden usar.  También contienen datos de prueba para verificar que todo funcione. La instalación de las paqueterías se realiza una sola vez.

## Paqueterías de CRAN

[CRAN](https://cran.r-project.org/) es el repositorio oficial de R contenido en una red de servidores ftp y web mantenidos por la comunidad R. 
Para que un paquete se publique en CRAN, debe pasar pruebas que garanticen que el paquete cumple con las políticas de la comunidad.

[Aquí](https://cran.r-project.org/web/packages/available_packages_by_name.html) puedes consultar todas las paqueterías disponibles en CRAN. A continuación instalaremos la paquetería `ggplot2`, que se encuentra en el repositorio CRAN.

### Instalación de paqueteria ggplot2 
```{r, eval=FALSE}
install.packages("ggplot2")
```

El comando `packageDescription()` muestra una descripción general sobre la paquetería.
```{r, eval=FALSE}
packageDescription("ggplot2")
```

El comando `help()` muestra la ayuda sobre la paquetería.
```{r, eval=FALSE}
help(package = "ggplot2")
```

Si quieres eliminar una paquetería, utiliza el comando `remove.packages()` indicando entre paréntesis el nombre de la paquetería.


## Paqueterías de Bioconductor

[Bioconductor](https://www.bioconductor.org/) es un repositorio de temas específicos para software de código abierto en bioinformática. Para instalar cualquier paquetería de Bioconductor, es necesario instalar **BiocManager**, que es el gestor de paqueterías de Bioconductor. 

### Instalación de BiocManager
```{r, eval=FALSE}
install.packages("BiocManager")
```

Una vez instalado BiocManager, ya podemos instalar las paqueterías que se encuentran en Bioconductor. [Aquí](https://www.bioconductor.org/packages/release/BiocViews.html#___Software) puedes revisar todas las paqueterías disponibles en Bioconductor.

### Instalación de paqueterías de Bioconductor. 
En este caso instalaremos la paquetería **AnnotationDbi**
```{r, eval=FALSE}
BiocManager::install("AnnotationDbi")
```



## Paqueterías de GitHub

[GitHub](https://github.com/) no es específico de R pero es el repositorio más popular para proyectos de código abierto. Su popularidad se debe al espacio ilimitado, la integración con git, control de versiones y su facilidad para compartir y colaborar con otros usuarios.

La instalación de paqueterías desde GitHub dependerá de instrucciones indicadas por los autores. 







<!--chapter:end:08-paqueterias.Rmd-->

---
Curso: "R para bioinformatica"
Autor: "Winter School"
Contacto: "cursos@wintergenomics.com"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.show = "hold")
```

# Heatmaps

Los heatmaps son una técnica de visualización de datos que mide la magnitud de un fenómeno en colores en dos dimensiones. La variación del color puede ser por tono o intensidad, haciendo obvia la lectura del fenómeno sobre el espacio que se trata.

Son el resultado obtenido al representar una matriz de valores en la que, en lugar de números, se muestra un gradiente de color proporcional al valor de cada variable en cada posición. 

Los heatmaps son ampliamente utilizados para visualizar e interpretar datos de expresión génica, principalmente para experimentos con microarrays y RNA-seq. También se puede combinar con métodos de agrupación, que agrupan genes y/o muestras en función de la similitud de su patrón de expresión génica. Esto puede ser útil para identificar genes que están comúnmente regulados o firmas biológicas asociadas con una condición particular (por ejemplo, una enfermedad o una condición ambiental).


##### Instalación
La instalación de paqueterías se realiza sólo una vez. Una vez que la librería o paquetería esté instalada, puedes omitir este paso
```{r, eval=FALSE}
install.packages("pheatmap")
```

Ahora cargaremos la paquetería. El llamado de librerías deberá hacerse cada que inicies una nueva sesión en R.
```{r}
library(pheatmap)
```


##### Directorio de trabajo
Imprime el directorio de trabajo actual
```{r, eval=F}
getwd() 
```

Asigna a un objeto la ruta de la carpeta de trabajo. Recuerda cambiar */docs/mydir* por los nombres de tus carpetas de trabajo
```{r}
directory <- "C:/docs/mydir" #Windows
directory <- "/home/users/mydir"  #Mac OS o linux
```

Ajusta el directorio de trabajo
```{r, eval=F}
setwd(directory)
```

Importación de datos

Los datos los puedes descargar de [aquí](https://drive.google.com/u/0/uc?id=1aS5-Zf03OeMRtZsCCLYFXAUQpesGy4IK&export=download). Recuerda guardarlos en la carpeta de trabajo que asignaste en el paso anterior.

```{r, eval=F}
data <- read.csv(file = "Datos.csv")
```

```{r, eval=T, echo=F}
data <- read.csv("~/Downloads/Datos.csv")
```

Vamos a restructurar los datos
```{r, eval=T}
rownames(data) <- data[,1]
samp2 <- data[,-1]
```

Transformaremos nuestros datos a una matriz para poder crear nuestro heatmap.
```{r, eval=T}
mat_data <- data.matrix(samp2[,1:ncol(samp2)])
mat_data
```


### Construyendo un heatmap básico
```{r, eval=T, fig.show='hold'}
pheatmap(mat_data)
```

### Cambiar el tamaño de letra 
Con los comandos `fontsize_col`(columnas) y `fontsize_row` (filas), puedes cambiar el tamaño de letra y hacerlo más grande o más pequeño.
```{r, eval=T, fig.show='hold'}
pheatmap(mat_data,
         fontsize_col=6,
         fontsize_row=6)

```


### Agregar un título a nuestro heatmap
`main` te permite agregar el título al Heatmap. Recuerda que el título que eligas debe estar entre comillas
```{r, eval=T, fig.show='hold'}
pheatmap(mat_data,
         fontsize_col=10,
         fontsize_row=10,
         main = "Mi primer heatmap")

```



### Cambiar los colores de nuestro heatmap.
La escala de colores fríos generalmente se usa en los heatmaps. `color` te permite cambiar los colores de la gráfica.

[Aquí](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf) y [aquí](https://htmlcolorcodes.com/) puedes revisar los colores disponibles en R que puedes usar en tus gráficas.

```{r, eval=T, fig.show='hold'}
pheatmap(mat_data,
         fontsize_col=10,
         fontsize_row=10,
         main = "Mi primer Heatmap",
         color = c("blue", "yellow","red"))

```

Agregar o cambiar las líneas de los clusters con `cluster_cols` y `cluster_rows`
```{r, eval=T, fig.show='hold'}
pheatmap(mat_data,
         fontsize_col=10,
         fontsize_row=10,
         main = "Mi primer heatmap",
         color = c("blue", "yellow","red"),
         cluster_cols=F,
         cluster_rows=T)
```


```{r, eval=T, fig.show='hold'}
pheatmap(mat_data,
         fontsize_col=10,
         fontsize_row=10,
         main = "Mi primer heatmap",
         color = c("blue", "yellow","red"),
         cluster_cols=F,
         cluster_rows=F)
```






<!--chapter:end:heatmaps.Rmd-->

